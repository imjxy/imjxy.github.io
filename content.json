{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"【博客搭建】从零开始的博客搭建","text":"本博客网站是基于B站up主codesheep的视频BV1Yb411a7ty一步步建立的，讲的很详细。作为第一篇文章，记录一下搭建博客的过程。 环境配置Node.js 首先下载node.s，我们搭建博客用到的hexo需要node.s。前往官网下载。 安装好后在控制台输入以下代码检测Node.js和npm的版本 1234node -v v12.16.3npm -v 6.14.4 安装cnpm（从淘宝镜像安装，若有vpn可直接安装）npm install -g cnpm --registry=http://registry.npm.taobao.org 用cnpm安装hexo框架cnpm install -g hexo-cli git 前往官网下载 搭建本地网站 创建一个新文件夹，作为存放博客的目录，如D:\\Blog 在控制台进入文件夹内并初始化cd D:\\Bloghexo init 启动本地网站1234hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 可以复制http://localhost:4000到浏览器查看初始博客网站，用的是默认主题，并且有一篇helloworld的博客。 部署到github 在github上新建仓库，命名为你的用户名.github.io，如imjxy.github.io 在博客文件夹下安装git部署插件cnpm install --save hexo-deployer-git 设置配置文件_config.yml(win可用记事本或写字板打开）在#Deployment下修改12345## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/imjxy/imjxy.github.io.git branch: master repo后跟刚才新建的仓库地址 注:以上每一项：后都要空一格 部署到githubhexo d输入github账号密码，部署成功后就可以用github用户名.github.io来访问了。 hexo常用指令 hexo s 启动本地网站（修改网站或者写完一篇博客后可用此方法在本地看看效果） hexo g 生成静态文件 hexo d 部署网站","link":"/2020/05/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"图片转base64小工具","text":"最近需要学习python制作可视化程序的东西，看了一些教程选择了pysider2来学习。由于之前makedown文档总是上传不了图片，所以搜了搜发现可以用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置，于是想顺便练习一下做一个小工具。 UI设计我用的是Qt的界面生成器Qt Designer，拖拖拽拽就可以直观的创建出程序大体的界面 12345class Transfer: def __init__(self): self.ui = QUiLoader().load('base64_turn.ui') self.ui.btn_select.clicked.connect(self.open) self.ui.btn_start.clicked.connect(self.transfer) 通过上述代码实现ui文件的加载与方法的绑定 功能设计文件读取123456789101112131415def open(self): filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) if filePath == None: QMessageBox.information(self, '提示', '文件为空，请重新操作') else: self.pic_path = filePath pic=QtGui.QPixmap(self.pic_path) self.ui.qlb_pic.setPixmap(pic) #self.ui.qlb_pic.resize(pic.width(), pic.height()) self.ui.le_select.setText(self.pic_path) 通过 getExistingDirectory 静态方法 选择目录。该方法，第一个参数是父窗口对象，第二个参数是选择框显示的标题。 如果是选取单个文件，通过 getOpenFileName 静态方法 可以设置提示文本内容，比如 123456filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) 因为该方法返回的是一个元组，第一个元素是选择的文件路径，第二个元素是文件类型，如果你只想获取文件路径即可，可以采用上面的代码写法。 如果用户点击了 选择框的 取消选择按钮，返回 空字符串。 图像转换12345def transfer(self): f = open(self.pic_path, 'rb') # 二进制方式打开图文件 ls_f = base64.b64encode(f.read()) # 读取文件内容，转换为base64编码 f.close() self.ui.tb_base64.setText(str(ls_f)) 记得要import base64 文件已提交至github 第一次给github提交代码，每天进步一点点","link":"/2020/05/06/%E5%9B%BE%E7%89%87%E8%BD%ACbase64%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"title":"基于mobilenetv2的识别demo","text":"依旧是在练习pyside2的使用，这次做了一个图像识别的demo，用的mobilenet来做识别 UI设计UI设计还比较简陋，毕竟现在还只是个demo，而且下午组会就要展示 Qt designer的各种Layout布局还在摸索，这样松松垮垮的实在太丑了，而且我看别人做的程序运行时部分地方有个像C#各种布局的那种框框，哎日后慢慢完善吧 功能设计打开文件1234567891011121314151617181920def open(self): filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) if filePath is None: QMessageBox.information(self, '提示', '文件为空，请重新操作') else: self.pic_path = filePath pic = QtGui.QPixmap(self.pic_path) self.ui.lb_pic1.setPixmap(pic) self.ui.le_select.setText(self.pic_path) time1 = time.perf_counter() s = self.predict(self.pic_path) time2 = time.perf_counter() self.ui.lb_time.setText('识别时间：' + str(time2 - time1) + 's') self.ui.lb_recores.setText('识别结果：' + str(s)) # self.ui.qlb_pic.resize(pic.width(), pic.height()) 这次的open函数相较于上篇博客的稍微复杂一点点，逻辑大概是这样的：打开文件→将原图像显示到第一个label中→调用预测函数，将图片绝对路径传给预测函数→把识别所用时间和识别结果显示到窗口上。 预测123def predict(self, pic_path): str = predict_alter.predict(pic_path) return str 其实就是调用一下预测函数，这里多说几句。 我用的模型是B站UP主霹雳吧啦Wz的教学视频里的，这里是他的GitHub，他讲的深度学习图像分类真的非常详细。 这个predict_alter是我修改了一下原文件，用的是之前训练好的参数。 具体的预测函数我就不粘了。 数据我测试的数据是苹果品种标准叶片图像和光谱数据集，选取了五种苹果叶片的RGB图像 展示 这个里面的经度纬度啊拍摄时间啊，是因为我看到python的exifread库可以读取图像的一些信息（使用Python获取图像的信息)，想测试一下。 那个“选择识别的种类”的多选框是日后准备完善的内容，手里还有fruit、flower的两个数据集，质量都蛮好的 右侧其实放置了四块放图像的label，因为昨天还看到了opencv可以提取图像各通道信息，下午就要组会了，明天在完善吧。","link":"/2020/05/07/%E5%9F%BA%E4%BA%8EMobileNetv2%E7%9A%84%E8%AF%86%E5%88%ABdemo/"},{"title":"【pat】1001（Python format 格式化函数）","text":"艰难的刷题又开始了。 问题描述1001 A+B Format Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −106≤a,b≤106. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 解决方法之前开始过很多次刷题，但是算法和数据结构方面实在是太薄弱了，不管是LeetCode还是pat还是oj都坚持不下去，这次必拿下大概吧 做第一题就充分暴露对语言的不熟悉了，这道题我还跟大一一样试图用乘法和取余取到每三个数然后加”，“ 但其实做除法时例如999001%1000=1而不是001，实在是太笨了 1234567891011121314151617181920def cal_plus(): global rem,res line = input().split(\" \") a, b = int(line[0]), int(line[1]) sum = a + b if (0 &lt; sum &lt; 1000) or (-1000 &lt; sum &lt; 0): #print(sum) return str(sum) else: rem = sum % 1000 sum = int(sum / 1000) res = str(rem) while ((sum &gt; 0 and sum &lt; 1000) or (sum &lt; 0 and sum &lt; -1000)): rem = sum % 1000 sum = int(sum / 1000) res = str(rem) + ',' + res res =str(sum) + ',' + res return res #print(res) 但是我去搜了搜，发现了Python format 格式化函数，其实学python时啃从入门到实践看到过，现在全忘了。 1234def cal(): line = input().split(\" \") a, b = int(line[0]), int(line[1]) print(\"{:,}\".format(a + b)) 几行轻轻松松拿下。 笔记Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。 字符串格式化 format 函数可以接受不限个参数，位置可以不按顺序 12&quot;{} {}&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 不设置指定位置，按默认顺序'hello world' 12&quot;{0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置'hello world' 12&quot;{1} {0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置'world hello world' 也可以设置参数 123456789print(\"网站名：{name}, 地址 {url}\".format(name=\"菜鸟教程\", url=\"www.runoob.com\")) # 通过字典设置参数site = {\"name\": \"菜鸟教程\", \"url\": \"www.runoob.com\"}print(\"网站名：{name}, 地址 {url}\".format(**site)) # 通过列表索引设置参数my_list = ['菜鸟教程', 'www.runoob.com']print(\"网站名：{0[0]}, 地址 {0[1]}\".format(my_list)) # \"0\" 是必须的 输出结果为： 123网站名：菜鸟教程, 地址 www.runoob.com网站名：菜鸟教程, 地址 www.runoob.com网站名：菜鸟教程, 地址 www.runoob.com 也可以向 str.format() 传入对象 12345class AssignValue(object): def __init__(self, value): self.value = valuemy_value = AssignValue(6)print('value 为: {0.value}'.format(my_value)) # \"0\" 是可选的 输出结果为： 1value 为: 6 数字格式化^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。 + 表示在正数前显示 +，负数前显示 -； （空格）表示在正数前加空格 b、d、o、x 分别是二进制、十进制、八进制、十六进制。 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:&gt;10d} 13 右对齐 (默认, 宽度为10) 13 {:&lt;10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) 123456'{:b}'.format(11)'{:d}'.format(11)'{:o}'.format(11)'{:x}'.format(11)'{:#x}'.format(11)'{:#X}'.format(11) 12345610111113b0xb0XB 闲话 这次好好做一个题就总结一下，至少可以坚持下来多学点东西 其实还是蛮想在重新看一下java，这周快点把手里事情了了，尽量这周末看一下","link":"/2020/05/07/%E3%80%90pat%E3%80%911001/"},{"title":"exifread--使用python获取图像信息（一）","text":"填一下坑，上次做那个识别demo提到了exifread来获取图像信息，来实践一下，今天内容不是太多空洞骑士白色宫殿跳跳乐要我狗命 exifread库的下载这个没什么特殊的地方，可以直接在命令提示符中输pip install exifread，或者通过在官网下载第三方库，然后放到本地文件夹里。 如果是在官网下载，下载以后将文件夹中的exifread文件夹放到python文件的lib/site-packages下 测试整个流程比较简单，总的来讲就是通过第三方库得到图像的参数，然后通过遍历或者是说调取的方式拿出你想要的值。 首先以二进制方式读取图像，然后通过exifread.process_file函数得到图像的信息。返回的是一个字典。读取它的keys可以看到它所包含的图像的参数。 首先我们来看一下我使用的测试图片 123456789101112img=open(self.pic_path,\"rb\")imageInfo=exifread.process_file(img)for key in imageInfo: print(key,\":\",imageInfo[key])print(\"**************************\")for item in imageInfo: if item == \"GPS GPSLongitude\": print(\"GPS经度 =\",imageInfo[item],imageInfo['GPS GPSLongitudeRef']) elif item==\"GPS GPSLatitude\": print(\"GPS纬度 =\",imageInfo[item],imageInfo['GPS GPSLatitudeRef']) elif item == \"Image DateTime\": print(\"拍摄时间 =\",imageInfo[item]) 来看看得到的imageInfo字典，我大概翻译了几个，其实意思也很好看懂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Image ImageLength : 3840Image Make : HUAWEI#大概是拍摄设备Image Orientation : 0#影像方向，Google直译Image BitsPerSample : [8, 8, 8]#图像位数Image DateTime : 2019:08:12 19:12:13#拍摄时间GPS GPSLatitude : [30, 32, 32]#GPS纬度GPS GPSAltitude : 0GPS GPSLatitudeRef : N（北纬或南纬）GPS GPSAltitudeRef : 1GPS GPSProcessingMethod : GPSGPS GPSVersionID : [2, 2, 0, 0]GPS GPSLongitudeRef : EGPS GPSTimeStamp : [11, 12, 8]GPS GPSLongitude : [114, 21, 7]GPS GPSDate : 2019-08-12Image GPSInfo : 8448Image YResolution : 72Image XResolution : 72Image ImageWidth : 5120Image Model : VCE-AL00Image Software : VCE-AL00 9.1.0.230(C00E230R1P1)Image YCbCrPositioning : CenteredImage ExifOffset : 272Image ResolutionUnit : Pixels/InchThumbnail ImageLength : 384Thumbnail YResolution : 72Thumbnail Compression : JPEG (old-style)Thumbnail JPEGInterchangeFormat : 8813Thumbnail JPEGInterchangeFormatLength : 19571Thumbnail XResolution : 72Thumbnail ImageWidth : 512Thumbnail Orientation : 0Thumbnail ResolutionUnit : Pixels/InchEXIF ExifVersion : 0210EXIF ApertureValue : 169/100EXIF SceneType : Directly PhotographedEXIF SubjectDistanceRange : 0EXIF ExposureBiasValue : 0EXIF ExposureProgram : Program NormalEXIF ColorSpace : sRGBEXIF MaxApertureValue : 169/100EXIF ExifImageLength : 3840EXIF BrightnessValue : 0EXIF DateTimeOriginal : 2019:08:12 19:12:13EXIF FlashPixVersion : 0100EXIF MakerNote : [35, 35, 42, 42, 111, 122, 110, 111, 114, 67, 79, 0]EXIF SubSecTimeOriginal : 159127EXIF WhiteBalance : AutoInteroperability InteroperabilityIndex : R98EXIF InteroperabilityOffset : 8665EXIF CustomRendered : CustomEXIF ExposureMode : Auto ExposureEXIF ExposureTime : 1/50EXIF Flash : Flash did not fireEXIF SubSecTime : 159127EXIF FNumber : 9/5EXIF ISOSpeedRatings : 100EXIF ExifImageWidth : 5120EXIF Saturation : NormalEXIF ComponentsConfiguration : YCbCrEXIF FileSource : Digital CameraEXIF FocalLengthIn35mmFilm : 43EXIF CompressedBitsPerPixel : 19/20EXIF SubSecTimeDigitized : 159127EXIF Contrast : NormalEXIF Sharpness : NormalEXIF DigitalZoomRatio : 1EXIF DateTimeDigitized : 2019:08:12 19:12:13EXIF ShutterSpeedValue : 298973/10000EXIF MeteringMode : PatternEXIF FocalLength : 79/20EXIF GainControl : NoneEXIF SceneCaptureType : StandardEXIF LightSource : DaylightEXIF SensingMethod : One-chip color area 下面是我想输出的内容 123拍摄时间 = 2019:08:12 19:12:13GPS纬度 = [30, 32, 32] NGPS经度 = [114, 21, 7] E exifread库的使用方法还是很简单的 闲话今天打空洞骑士打得有点多，内容比较少，我还看到了调用Exifread模块获取到照片中的经纬度信息，然后再调用高德地图或是百度地图的逆地理编码API，即可得到照片中的地理位置所在，效果如下图所示 明天想来实现一下。","link":"/2020/05/08/exifread-%E4%BD%BF%E7%94%A8python%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF/"},{"title":"exifread--使用python获取图像信息（二）","text":"今天进一步完善了一下，实现了调用百度地图API根据exifread获取的GPS信息查询具体地址 UI设计 功能设计打开文件12345678910111213141516def open(self): filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) if filePath is None: QMessageBox.information(self, '提示', '文件为空，请重新操作') else: self.pic_path = filePath self.ui.le_select.setText(str(filePath)) Info = self.GetInfo(self.pic_path) address = self.GetLocation(Info) Info['地址'] = address self.show(filePath, Info) 打开文件的函数依旧跟前几次的相类似，这次尽量精简了一些，把一些流程写成了函数来调用 获取图像信息1234567891011121314151617def GetInfo(self, path): f = open(path, 'rb') tags = exifread.process_file(f) #print(tags) info = { 'Image DateTime(拍摄时间)': tags.get('Image DateTime', '0').values, 'GPS GPSLatitudeRef(纬度标志)': tags.get('GPS GPSLatitudeRef', '0').values, 'GPS GPSLatitude(纬度)': tags.get('GPS GPSLatitude', '0').values, 'GPS GPSLongitudeRef(经度标志)': tags.get('GPS GPSLongitudeRef', '0').values, 'GPS GPSLongitude(经度)': tags.get('GPS GPSLongitude', '0').values } lat = self.process_num(info.get('GPS GPSLatitude(纬度)')) lng = self.process_num(info.get('GPS GPSLongitude(经度)')) info['GPS GPSLatitude(纬度)'] = lat info['GPS GPSLongitude(经度)'] = lng return info 这里把感兴趣的东西从全部图像信息中挑了出来，形成一个新的字典，再把经纬度转换成常见的数字格式，便于查看也便于后面的查询操作。 经纬度转化12345678def process_num(self, GPSlist): # 处理列表中最后一个元素 GPSlist_last = eval(str(GPSlist[-1])) # 转化 new_GPSlist = GPSlist[0].num + GPSlist[1].num / 60 + GPSlist_last / 3600 return '{:.4f}'.format(new_GPSlist) 原始数据中经纬度的格式是这样的： 12GPS GPSLatitude : [30, 32, 32]GPS GPSLongitude : [114, 21, 7] 而调用百度API时需要我们常见的那种数字化的格式，计算方法如上面代码所示 这里我为了显示起来好看，经纬度只取到了四位。 查询地址1234567891011def GetLocation(self, info): lat = info['GPS GPSLatitude(纬度)'] lng = info['GPS GPSLongitude(经度)'] url = \"http://api.map.baidu.com/reverse_geocoding/v3/?ak=你申请的百度地图API的秘钥&amp;output=json&amp;coordtype=wgs84ll&amp;language_auto=1&amp;extensions_town=true&amp;location=\" + lat + \",\" + lng req = urllib.request.urlopen(url) res = req.read().decode(\"utf-8\") print(res) str1 = json.loads(res) jsonResult = str1.get('result') formatted_address = jsonResult.get('formatted_address') return formatted_address 这里需要自己去申请一个百度地图API的项目，很简单也完全免费。 这里会返回一个json格式的数据： 1{&quot;status&quot;:0,&quot;result&quot;:{&quot;location&quot;:{&quot;lng&quot;:114.36382716144719,&quot;lat&quot;:30.546202080533587},&quot;formatted_address&quot;:&quot;湖北省武汉市武昌区茶港路&quot;,&quot;business&quot;:&quot;水果湖,街道口,武珞路&quot;,&quot;addressComponent&quot;:{&quot;country&quot;:&quot;中国&quot;,&quot;country_code&quot;:0,&quot;country_code_iso&quot;:&quot;CHN&quot;,&quot;country_code_iso2&quot;:&quot;CN&quot;,&quot;province&quot;:&quot;湖北省&quot;,&quot;city&quot;:&quot;武汉市&quot;,&quot;city_level&quot;:2,&quot;district&quot;:&quot;武昌区&quot;,&quot;town&quot;:&quot;珞珈山街道&quot;,&quot;town_code&quot;:&quot;420106013&quot;,&quot;adcode&quot;:&quot;420106&quot;,&quot;street&quot;:&quot;茶港路&quot;,&quot;street_number&quot;:&quot;&quot;,&quot;direction&quot;:&quot;&quot;,&quot;distance&quot;:&quot;&quot;},&quot;pois&quot;:[],&quot;roads&quot;:[],&quot;poiRegions&quot;:[],&quot;sematic_description&quot;:&quot;&quot;,&quot;cityCode&quot;:218}} 从中获取自己感兴趣的数据就好 显示到窗口123456789def show(self, path, info): pic = QtGui.QPixmap(path) self.ui.lb_pic.setPixmap(pic) self.ui.lb_pictime.setText(\"拍摄时间：\" + str(info['Image DateTime(拍摄时间)'])) self.ui.lb_picGPS.setText(\"经纬度：\" + str(info['GPS GPSLatitudeRef(纬度标志)']) + ' ' + str(info['GPS GPSLatitude(纬度)']) + ' ' + str(info['GPS GPSLongitudeRef(经度标志)']) + ' ' + str(info['GPS GPSLongitude(经度)'])) self.ui.lb_piclocation.setText(\"位置：\" + info['地址']) 这里没什么好说的了，把图片和获取到的信息显示到窗口的label控件上就好。 测试我测试了很多张图片，其中在自己家拍摄的图片定位的非常详细，精度可以到街道号，而且我上面经纬度只取到了小数点后四位。这里还是用去年拍到的夏天武大的云为例。 结果如下图所示： 但是我接下来测试了不同设备拍摄的数据，其中HUAWEI mate20、OPPO R9s还有一些手机型号拍摄的图像是解析不到任何数据的，一加7获取了很少的内容，例如拍摄时间等，没有GPS信息（可能和相机设置有关），而且不同设备返回的exifread字典是不一样的如canon相机，这个内容太多就不放在这里了，数据格式不一样的话是需要根据具体格式来写代码的。 闲话 虽然大部分的设备都没有解析的数据，但是我的HUAWEI Nova4显示的完完整整，具体是不是设备的原因也不敢确定，还是要增加隐私意识。 这次用了百度地图API，看了看官网好像可以干的事情很多，以后想在多探索一些用法，先留下一个坑 json格式和json库也想好好的看一看，留下第二个坑","link":"/2020/05/09/exifread-%E4%BD%BF%E7%94%A8python%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"mysql的安装与摸鱼","text":"昨天摸鱼了么？ 摸了 今天C#布置的作业是在上次课的爬虫程序的基础上，改写数据存储和显示部分，使用数据库进行存取。大二上完数据库就把Oracle删掉了，这次从零开始的数据库安装与摸鱼。 MySQL的下载与配置Windows 上安装 MySQL 比较简单，最新版本可以在 MySQL 下载 中下载中查看。 下载完后，我们将 zip 包解压到相应的目录，这里我解压到了D:\\mysql 在该文件夹下创建my.ini编辑 my.ini 配置以下基本信息： 1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB ini文件的话就是新建一个文本文档另存为my.ini就好 启动数据库以管理员身份运行cmd，切换到MySQL目录下的bin文件里 初始化数据库: mysqld --initialize --console 执行完成后，会输出 root 用户的初始默认密码，就在最后显示的最后一行A temporary password is generated for root@localhost:后面的东西，建议先保存下来，我因为第一次配置出错，把cmd关掉后忘了保存初始root密码，选择了从头再来。 输入以下安装命令： mysqld install 启动输入以下命令即可： net start mysql 登录MySQL当 MySQL 服务已经运行时， 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中， 首先打开命令提示符， 输入以下格式的命名: mysql -h 主机名 -u 用户名 -p -h : 指定客户端所要登录的 MySQL 主机名， 登录本机(localhost 或 127.0.0.1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录， 如果所要登录的用户名密码为空， 可以忽略此选项。 如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可： mysql -u root -p 按回车确认， 如果安装正确且 MySQL 正在运行，会让你输入密码，把刚才的初始root输入就好了。 进入后直接：SET PASSWORD = '123456'把初始密码改掉。 MySQL的使用（以C#为例）首先把题目放一下： 123编写一个网络爬虫，从一个网址中如（http://hao.360.cn）开始，获取网页内容，找到网页中的链接，做进一步下载（只要求一层）。要求：1. 使用多线程等技术，实现并行下载，并在Winform界面中，实时显示当前已下载页面的个数（要考虑多线程加锁）；2. 使用表格控件，显示已下载页面的链接，使用正则表达式，筛选下载的页面中的汉字，并统计汉字个数，并显示在表格控件中。 本次作业的要求是把这个里面的链接和文字个数储存到数据库中，并从数据库中查找和显示。 修改数据库1234567891011121314151617181920212223private void Insert(string url, int num) { String connStr = &quot;server=127.0.0.1;port=3306;user=root;password=123456; database=websites;&quot;; MySqlConnection conn = new MySqlConnection(connStr); try { conn.Open(); string sql = &quot;insert into url_num(URL,NUM) values(@URL,@NUM)&quot;; MySqlCommand cmd = new MySqlCommand(sql, conn); cmd.Prepare(); cmd.Parameters.AddWithValue(&quot;@URL&quot;, url); cmd.Parameters.AddWithValue(&quot;@NUM&quot;, num); int result = cmd.ExecuteNonQuery(); } catch (MySqlException e) { MessageBox.Show(e.Message); } finally { conn.Close(); } } 插入函数，把网址和汉字个数插入到已经建好的表里。 连接数据库具体步骤就是： 定义连接字符串 1String connStr = &quot;server=127.0.0.1;port=3306;user=root;password=123456; database=websites;&quot;; 创建Connection对象 1MySqlConnection conn = new MySqlConnection(connStr); 打开与数据库的连接 1conn.Open(); 这一步以及之后对数据库的操作最好放在try里，finally里放个conn.Close() 查询数据库1234567891011121314151617181920212223242526272829303132private void btn_show_Click_1(object sender, EventArgs e) { String connStr = &quot;server=127.0.0.1;port=3306;user=root;password=123456; database=websites;&quot;; MySqlConnection conn = new MySqlConnection(connStr); try { conn.Open(); string sql = &quot;select * from url_num&quot;; MySqlCommand cmd = new MySqlCommand(sql, conn); MySqlDataReader data = cmd.ExecuteReader(); while (data.Read()) { string url = data[&quot;URL&quot;].ToString(); string num = data[&quot;NUM&quot;].ToString(); ListViewItem item = new ListViewItem { Text = url }; item.SubItems.Add(num); lv_download.Items.Add(item); } } catch (MySqlException e1) { MessageBox.Show(e1.Message); } finally { conn.Close(); } } 其实和修改数据库大致流程一样，就是sql语句换了一下。 闲话 MySQL语句以后单开一篇说说吧，耶又是一个坑 makedown文法也要单开一篇，今天写引用格式又去查了一遍 等哪天想摸鱼了再更博客主题配置的文章","link":"/2020/05/11/mysql%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"基于mobilenetv2的识别demo--服务器的配置与识别速度的优化","text":"优化了一下之前那个识别demo的识别速度，并且把模型放到了服务器上，还是有很多毛病就是了。 我真的这11天没有摸鱼（大概吧） 其实这11天也不是在摸鱼，实验室老师突然要我们参加互联网加，一周之内参赛材料改了三四个版本，完了之后又发现自己侥幸过了实习的一面，又疯狂准备了两天面经（虽然还是挂了，以后有机会记录一下，还是学到不少东西的）然后给自己放了两天假，哎希望自己能再自律一点吧。 客户端功能设计UI设计 这次感觉UI改的稍微好看一点了，功能比较明确，一会可以看看后面的展示。 功能设计初始化123456789class Client: def __init__(self): self.ui = QUiLoader().load('client.ui') self.ui.btn_select.clicked.connect(self.open) self.ui.btn_connect.clicked.connect(self.conn) self.ui.btn_load.clicked.connect(self.load) self.ui.btn_disconnect.clicked.connect(self.disconnect) self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.pic_path = '' 依旧是老生常谈的加载ui，绑定函数 打开文件1234567891011121314def open(self): filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"C:\\Users\\HASEE\\Desktop\\deep-learning-for-image-processing-master\\data_set\\appleleaf_data\\train\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) if filePath is None: QMessageBox.information(self, '提示', '文件为空，请重新操作') else: self.pic_path = filePath pic = QtGui.QPixmap(self.pic_path) self.ui.lb_pic1.setPixmap(pic) self.ui.le_select.setText(self.pic_path) 打开文件函数，这里没有改动，按下选择文件按钮后弹出文件选择框。再说一下文件选择窗口的QFileDialog.getOpenFileName方法吧： 123456filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) 因为该方法返回的是一个元组，第一个元素是选择的文件路径，第二个元素是文件类型，如果你只想获取文件路径即可，可以采用上面的代码写法。 如果用户点击了 选择框的 取消选择按钮，返回 空字符串。 更新信息123def showinbox(self, s): self.ui.tb_text.append(s) self.ui.tb_text.ensureCursorVisible() 这里就是一个把字符串更新到TextBrowser里的方法，通过 append 方法在编辑框末尾添加文本内容，有时，浏览框里面的内容长度超出了可见范围，我们在末尾添加了内容，往往希望控件自动翻滚到当前添加的这行，可以通过 ensureCursorVisible 方法来实现 socket 连接123456789def conn(self): IP = self.ui.le_ip.text() SEVER_PORT = int(self.ui.le_port.text()) try: self.s.connect((IP, SEVER_PORT)) except socket.error as msg: self.showinbox(str(msg)) # sys.exit(1) self.showinbox(self.s.recv(1024).decode(\"utf-8\")) 这里就是将用户输入的IP和端口作为地址连接到服务器，并且接收服务器确认连接的'Hi, Welcome to the server!'消息，如果出错的话，把异常信息更新到TextBrowser里。 断开连接1234def disconnect(self): self.s.send(b\"stop\") self.s.close() self.showinbox(\"已断开和服务器的连接\") 点击按钮“断开连接”时调用，首先向服务器发送“stop”告诉服务器要断开连接，b放在字符串前将字符串转为socket可以发送的字节形式。 选择种类12345678def Kind_selsct(self): kind = self.ui.cb_kind.currentText() if kind == \"fruit(apple,banana,pear,peach,orange)\": return b\"fruit\" elif kind == \"flower(daisy,dandelion,roses,sunflowers,tulips)\": return b\"flower\" elif kind == \"appleleaf(170,171,172,173,174）\": return b\"appleleaf\" 这里就是跟那个组合选项框有关的函数了，目前手里有这三个数据集，水果的数据集之前训练过但是没有保存参数文件，数据集实在太大了就没有训练这个。 可以使用 currentText 方法来获取当前 选中的选项 的文本 上传文件123456789101112131415161718192021222324252627282930313233343536373839404142def load(self): self.s.send(b\"load\") filepath = self.pic_path if os.path.isfile(filepath): # 定义定义文件信息。128s表示文件名为128bytes长，l表示一个int或log文件类型，在此为文件大小 fileinfo_size = struct.calcsize('128sl') # 定义文件头信息，包含文件名和文件大小 fhead = struct.pack( '128sl', os.path.basename(filepath).encode(encoding=\"utf-8\"), os.stat(filepath).st_size ) print('client filepath: {0}'.format(filepath)) self.s.send(fhead) fp = open(filepath, 'rb') while 1: data = fp.read(1024) if not data: print('{0} file send over...'.format(filepath)) break self.s.send(data) # print(\"in\") # print(\"out\") kindnum = self.Kind_selsct() text = \"您选择的类别是\" + str(kindnum)[2:-1] self.showinbox(text) self.showinbox(self.s.recv(1024).decode(\"utf-8\")) self.s.send(kindnum) time1=time.time() result=self.s.recv(1024).decode(\"utf-8\") time2=time.time() thetime=time2-time1 thetime=\"{:.2f}\".format(thetime) self.ui.lb_time.setText(\"识别时间：\"+thetime+\"s\") result=result.split(',') probability=result[1][0:-1] result=result[0][2:-1] self.showinbox(\"结果为\"+result+\"的概率为\"+probability) self.ui.lb_recores.setText(\"识别结果：\"+result) self.showinbox(self.s.recv(1024).decode(\"utf-8\")) self.showinbox(\"\\n\") 这个里面涉及的东西还蛮多的，我一条条按顺序说吧 其实关于识别速度的优化这里真的非常简单，都不能叫做优化，应该说是我终于正确使用了，就是在服务器开始时就初始化模型，之前那个每次5s是因为每次识别都初始化了模型，而且跟数据集的大小也有关，数据集越大，模型效果越好，识别速度也就越快（大概） 使用os.path.isdir()函数判断某一路径是否为目录，返回值为true或false struct数据格式转换 Python是一门非常简洁的语言，对于数据类型的表示，不像其他语言预定义了许多类型（如：在C#中，光整型就定义了8种），它只定义了六种基本类型：字符串，整数，浮点数，元组，列表，字典。通过这六种数据类型，我们可以完成大部分工作。但当Python需要通过网络与其他的平台进行交互的时候，必须考虑到将这些数据类型与其他平台或语言之间的类型进行互相转换问题。打个比方：C++写的客户端发送一个int型(4字节)变量的数据到Python写的服务器，Python接收到表示这个整数的4个字节数据，怎么解析成Python认识的整数呢？ Python的标准模块struct就用来解决这个问题。 写了写发现struct模块的内容有点多，我放到明天来说吧 下次一定 服务器功能设计服务器类123456789101112131415161718192021class Sever: def __init__(self): # 创建socket self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket_service() def socket_service(self): try: self.s.bind(('127.0.0.1', 6666)) self.s.listen(10) except socket.error as msg: print(msg) sys.exit(1) print('Waiting connection...') while 1: conn, addr = self.s.accept() t = threading.Thread(target=deal_data, args=(conn, addr)) t.start() 首先创建socket，以本机作为服务器，端口设置为‘6666’，每有一个客户端连接创建一个线程来运行，让线程去执行deal_data函数。 数据处理函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def deal_data(conn, addr): print('Accept new connection from {0}'.format(addr)) # conn.settimeout(500) conn.send('Hi, Welcome to the server!'.encode(\"utf-8\")) while 1: text=conn.recv(1024).decode('utf-8') if text==\"load\": fileinfo_size = struct.calcsize('128sl') buf = conn.recv(fileinfo_size) if buf: filename, filesize = struct.unpack('128sl', buf) fn = filename.strip(b\"\\x00\").decode(\"utf-8\") new_filename = os.path.join('./', 'new_' + fn) print(new_filename, filesize) print('file new name is {0}, filesize if {1}'.format(new_filename, filesize)) recvd_size = 0 # 定义已接收文件的大小 fp = open(new_filename, 'wb') print('start receiving...') while not recvd_size == filesize: if filesize - recvd_size &gt; 1024: data = conn.recv(1024) recvd_size += len(data) else: data = conn.recv(filesize - recvd_size) recvd_size = filesize fp.write(data) fp.close() # print(type(fp)) print('end receive...') conn.send('服务器成功接收文件'.encode(\"utf-8\")) # result = predict.predict(new_filename) # result = str(result) # conn.send(result.encode(\"utf-8\")) text = conn.recv(1024).decode('utf-8') # print(text) result = predict(new_filename, text) result = str(result) conn.send(result.encode(\"utf-8\")) # print(conn.recv(1024).decode('utf-8')) # print(str(addr)+\"断开连接\") # conn.close() # break conn.send('服务器正等待下一份文件...'.encode(\"utf-8\")) else: print(str(addr)+\"断开连接\") conn.close() break 逻辑大概是这样的：一旦与一个客户端建立连接后，返回'Hi, Welcome to the server!'提示客户端已成功连接，之后进入while循环处理接收并识别图片。首先判断用户传来的信号是load还是stop，如果是stop就断开连接（测试的时候断开连接是有问题的，等以后改进吧），如果是load，就先接收图片，再对图片调用预测函数。 关于文件发送与接收的struct这个用法放到后面来说。 代码里注释掉的测试用的东西有些多，以后注意删掉吧还是。 模型初始化及预测函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546model = MobileNetV2(num_classes=5)def predict(pic_path, flag): im_height = 224 im_width = 224 # load image img = Image.open(pic_path) # resize image to 224x224 img = img.resize((im_width, im_height)) plt.imshow(img) # scaling pixel value to (-1,1) img = np.array(img).astype(np.float32) img = ((img / 255.) - 0.5) * 2.0 # Add the image to a batch where it's the only member. img = (np.expand_dims(img, 0)) if flag == \"appleleaf\": # read class_indict try: json_file = open('./class_indices_appleleaf.json', 'r') class_indict = json.load(json_file) except Exception as e: print(e) exit(-1) # model.build((None, 224, 224, 3)) # when using subclass model model.load_weights('./save_weights/appleleaf_resMobileNetV2.ckpt') elif flag==\"flower\": # read class_indict try: json_file = open('./class_indices_flower.json', 'r') class_indict = json.load(json_file) except Exception as e: print(e) exit(-1) # model.build((None, 224, 224, 3)) # when using subclass model model.load_weights('./save_weights/flower_resMobileNetV2.ckpt') result = np.squeeze(model.predict(img)) prediction = tf.keras.layers.Softmax()(result).numpy() predict_class = np.argmax(result) s = class_indict[str(predict_class)], prediction[predict_class] return s 这个地方不懂的可以去翻看上一个demo博客里我放的教程链接，再次强推。 哎说起这个实验室学长推荐我们换成pytorch，好在这个教程里也有，up主一生平安。 结果展示 yeah 总结直接把周报这块的内容贴到这里吧 进展： 加入了花朵数据集的识别，水果数据集的权重正在训练 优化了识别速度，服务器启动时就初始化模型 实现了连续上传识别 调整了服务器结构，改成类的形式便于调用 修改了客户端UI 不足： 断开连接后实际上是个假断开，应该是服务器的问题，还需要学习后端的知识进一步修改代码 目前还没有想到多指标识别应该怎样处理 打包总是Qt库出现问题无法打包，查阅后可能pyinstaller和python3.7有不兼容的问题，准备下一个3.5的环境尝试打包，如果打包依旧不成功，考虑用其他语言完成客户端的搭建 闲话 互联网加这个事就不说了，如果最后真的在老师和学长们的帮助下有机会得奖，会更一篇各项材料的准备和编写的博客的，到时候再说心路历程吧。 腾讯暑期实习面试这个，其实是我有一天复习烦了做了个简历投了后端，没想到被捞了，还过了电话一面。经过这两次面试其实学到了很多东西，面试官都很nice，第二个面试官在我问过他对我有什么建议后真的对我提了一些东西，他说的我的知识面太窄也是事实。趁着这次大创要做服务器，争取按照后端技术栈好好学一下，增长经验。","link":"/2020/05/22/%E5%9F%BA%E4%BA%8Emobilenetv2%E7%9A%84%E8%AF%86%E5%88%ABdemo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AF%86%E5%88%AB%E9%80%9F%E5%BA%A6%E7%9A%84%E4%BC%98%E5%8C%96/"},{"title":"python中struct模块的使用","text":"昨天说过的关于数据格式转换的struct模块 Python是一门非常简洁的语言，对于数据类型的表示，不像其他语言预定义了许多类型（如：在C#中，光整型就定义了8种），它只定义了六种基本类型：字符串，整数，浮点数，元组，列表，字典。通过这六种数据类型，我们可以完成大部分工作。但当Python需要通过网络与其他的平台进行交互的时候，必须考虑到将这些数据类型与其他平台或语言之间的类型进行互相转换问题。打个比方：C++写的客户端发送一个int型(4字节)变量的数据到Python写的服务器，Python接收到表示这个整数的4个字节数据，怎么解析成Python认识的整数呢？ Python的标准模块struct就用来解决这个问题。 本文大量参考python之struct详解、【Python】struct 模块、[python struct详解]。 作用 按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送; 按照指定格式将字节流转换为Python指定的数据类型; 处理二进制数据,如果用struct来处理文件的话,需要用’wb’,’rb’以二进制(字节流)写,读的方式来处理文件; 处理c语言中的结构体; 主要函数 函数 return 作用 pack(fmt,v1,v2…) string 按照给定的格式(fmt),把数据v1,v2等等转换成字符串(字节流),并将该字符串返回 pack_into(fmt,buffer,offset,v1,v2…) None 按照给定的格式(fmt),将数据转换成字符串(字节流),并将字节流写入以offset开始的buffer中.(buffer为可写的缓冲区,可用array模块) unpack(fmt,v1,v2…..) tuple 按照给定的格式(fmt)解析字节流,并返回解析结果 pack_from(fmt,buffer,offset) tuple 按照给定的格式(fmt)解析以offset开始的缓冲区,并返回解析结果 calcsize(fmt) size of fmt 计算给定的格式(fmt)占用多少字节的内存，注意对齐方式 其中格式fmt的构成包括下面数据类型和数据对齐方式 数据类型 Format C Type Python type Standard Notes x pad byte no value c char bytes of length 1 1 b signed char integer 1 (1), (3) B unsigned char integer 1 (3) ? _Bool bool 1 (1) h short integer 2 (3) H unsigned short integer 2 (3) i int integer 4 (3) I unsigned int integer 4 (3) l long integer 4 (3) L unsigned long integer 4 (3) q long long integer 8 (2), (3) Q unsigned long long integer 8 (2), (3) n ssize_t integer (4) N size_t integer (4) e (7) float 2 (5) f float float 4 (5) d double float 8 (5) s char[] bytes p char[] bytes P void * integer (6) 备注： ? 转换码对应于 C99 定义的 _Bool 类型。如果此类型不可用，则使用 char 进行模拟。在标准模式下，它始终由一个字节表示。 仅当平台 C 编译器支持 C long long，或者在 Windows 上支持 __int64时，q 和 Q 转换代码才能以纯模式提供。它们始终以标准模式提供。 当尝试使用任何整数转换码打包非整数时，如果非整数具有 __index __() 方法，则调用该方法以在打包之前将参数转换为整数。 n 和 N 转换码仅适用于本机大小（选择为默认值或带有 @ 字节顺序字符）。对于标准大小，您可以使用适合您的应用程序的其他整数格式。 对于 f，d 和 e 转换码，打包表示使用 IEEE 754 binary32，binary64 或binary16 格式（分别用于f，d 和 e），无论浮平台用的什么浮点格式。 P 格式字符仅适用于本机字节排序（选择为默认字符或带有 @ 字节顺序字符）。字节顺序字符 = 选择使用基于主机系统的小端或大端排序。 struct 模块不会将其解释为本机排序，因此 P 格式不可用。 IEEE 754 二进制 16 “半精度” 类型是在 2008 年的 IEEE 754 标准修订版中引入的。它有一个符号位，一个 5 位指数和 11 位精度（显式存储 10 位），并且可以完全精确地表示大约 6.1e-05和6.5e + 04 之间的数字。 C编译器并不广泛支持这种类型：在典型的机器上，unsigned short 可用于存储，但不能用于数学运算。有关详细信息，请参阅有关半精度浮点格式的 Wikipedia 页面。 格式字符之前可以是整数重复计数。例如，格式字符串 4h 表示与 hhhh 完全相同。 格式之间的空白字符被忽略；计数及其格式不得包含空格。 对于 s 格式字符，count 被解释为字节的长度，而不是像其他格式字符那样的重复计数。例如，10s 表示单个 10 字节字符串，而 10c 表示 10 个字符。如果未给出计数，则默认为1。对于打包，字符串将被截断或填充为适当的空字节以使其适合。对于解包，生成的字节对象始终具有指定的字节数。作为一种特殊情况，0 表示单个空字符串（而 0c 表示 0 个字符）。 当使用整数格式（b，B，h，H，i，I，l，L，q，Q）之一打包值 x 时，如果 x 超出该格式的有效范围，则引发 struct.error。 p 格式字符编码 “Pascal字符串”，表示存储在固定字节数中的短可变长度字符串，由 count 给出。存储的第一个字节是字符串的长度，或255，取较小者。字符串的字节如下。如果传入 pack() 的字符串太长（长于 count-1），则只存储字符串的前导 count-1 字节。如果字符串短于 count-1，则用空字节填充，以便使用所有字节中的精确计数字节。请注意，对于 unpack()，p 格式字符使用 count 个字节，但返回的字符串永远不会包含超过 255 个字节。 对于 ？ 格式字符，返回值为 True 或 False。打包时，使用参数对象的真值。将打包本机或标准 bool 表示中的 0 或 1，并且在解包时任何非零值都将为 True。 数据对齐方式为了同c中的结构体交换数据，还要考虑有的c或c++编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下： 使用方法是放在fmt的第一个位置，就像‘@5s6sif’ 示例1： 12345678910111213struct Header{ unsigned short id; char[4] tag; unsigned int version; unsigned int count;} 通过socket.recv接收到了一个上面的结构体数据，存在字符串s中，现在需要把它解析出来，可以使用unpack()函数。 123import structid, tag, version, count = struct.unpack(\"!H4s2I\", s) 上面的格式字符串中，!表示我们要使用网络字节顺序解析，因为我们的数据是从网络中接收到的，在网络上传送的时候它是网络字节顺序的.后面的H表示 一个unsigned short的id,4s表示4字节长的字符串，2I表示有两个unsigned int类型的数据. 就通过一个unpack，现在id, tag, version, count里已经保存好我们的信息了. 同样，也可以很方便的把本地数据再pack成struct格式. 1ss = struct.pack(\"!H4s2I\", id, tag, version, count) pack函数就把id, tag, version, count按照指定的格式转换成了结构体Header，ss现在是一个字符串(实际上是类似于c结构体的字节流)，可以通过socket.send(ss)把这个字符串发送出去. 在我一开头举的那几个参考网站里还有很多和详细的例子。 闲话 其实昨天就开始写这篇了，但是这个表格复制的我心态爆炸，一直拖到了今天晚上（2020/5/24/20:32) 最近复习效率依旧低下，甚至大白天就给自己找游戏玩了，哎还是要多push自己，从今天开始复习专业课，保证每天的产出","link":"/2020/05/23/python%E4%B8%ADstruct%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Java的基本程序设计结构——《Java核心技术卷一：基础知识》","text":"老老实实准备学Java，大二课上学的考完试基本都还给老师了，准备好好啃完这本《Java核心技术卷一：基础知识》 今天下午把第三章Java的基本程序设计结构看完了，其实就是Java的一些最最基础的知识，记录一下，首先跟着书做了一张思维导图，然后我把一些不太知道的点写了写代码练了一下。 思维导图 要点构建字符串如果需要由较短的字符串构建字符串，采用字符串连接的方式效率比较低。每次连接字符串时，都会构建一个新的String对象，既耗时又占空间。使用StringBuilder类就可以避免这个问题的发生。 123456789101112public class Test { public static void main(String[] args) { char ch = 'A'; String str = \"BC\"; StringBuilder builder = new StringBuilder(); builder.append(ch); builder.append(str); String completedString = builder.toString(); System.out.println(completedString); }} 读取输入要通过控制台进行输入，首先要构造一个Scanner对象，并与“标准输入流”System.in关联。 1234567891011public class Test { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.println(\"What is your name?\"); String name = in.nextLine(); /*String name = in.next();//读取一个单词 String age = in.nextInt(); String number = in.nextDouble();*/ }} 数组排序这里到没什么好说的，书上有一个代码看着挺有意思敲了一下 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Arrays;import java.util.Scanner;/** * This program demonstrates array manipulation. */public class LotteryDrawing { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.print(\"How many numbers do you need to draw?\"); int k = in.nextInt(); System.out.print(\"What is the highest number you can draw?\"); int n = in.nextInt(); //fill an array with numbers 1 2 3... n int[] numbers = new int[n]; for (int i = 0; i &lt; numbers.length; i++) numbers[i] = i + 1; //draw k numbers and put them into a second array int[] result = new int[k]; for (int i = 0; i &lt; result.length; i++) { //make a random index between 0 and n-1 int r = (int) (Math.random() * n); //pick the element at the random location result[i] = numbers[r]; //move the last element into the random location numbers[r]=numbers[n-1]; n--; } //print the sorted array Arrays.sort(result); System.out.println(\"Bet the following combination.It'll make you rich!\"); for(int r:result) System.out.println(r); }} 闲话IDEA天下第一，IDEA太美了。","link":"/2020/06/02/Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"},{"title":"嵌入式系统复习（一）","text":"每章做了一些思维导图 没啥用，纯粹记录一下，硬件真是一生之敌 嵌入式今年属实大失败，从作业到大作业，乱七八糟的事层出不穷。","link":"/2020/06/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"pyside2","slug":"pyside2","link":"/tags/pyside2/"},{"name":"pat","slug":"pat","link":"/tags/pat/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"exifread","slug":"exifread","link":"/tags/exifread/"},{"name":"struct","slug":"struct","link":"/tags/struct/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"嵌入式","slug":"嵌入式","link":"/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"categories":[{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"java","slug":"java","link":"/categories/java/"}]}