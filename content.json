{"pages":[],"posts":[{"title":"【博客搭建】从零开始的博客搭建","text":"本博客网站是基于B站up主codesheep的视频BV1Yb411a7ty一步步建立的，讲的很详细。作为第一篇文章，记录一下搭建博客的过程。 环境配置Node.js 首先下载node.s，我们搭建博客用到的hexo需要node.s。前往官网下载。 安装好后在控制台输入以下代码检测Node.js和npm的版本 1234node -v v12.16.3npm -v 6.14.4 安装cnpm（从淘宝镜像安装，若有vpn可直接安装）npm install -g cnpm --registry=http://registry.npm.taobao.org 用cnpm安装hexo框架cnpm install -g hexo-cli git 前往官网下载 搭建本地网站 创建一个新文件夹，作为存放博客的目录，如D:\\Blog 在控制台进入文件夹内并初始化cd D:\\Bloghexo init 启动本地网站1234hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 可以复制http://localhost:4000到浏览器查看初始博客网站，用的是默认主题，并且有一篇helloworld的博客。 部署到github 在github上新建仓库，命名为你的用户名.github.io，如imjxy.github.io 在博客文件夹下安装git部署插件cnpm install --save hexo-deployer-git 设置配置文件_config.yml(win可用记事本或写字板打开）在#Deployment下修改12345## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/imjxy/imjxy.github.io.git branch: master repo后跟刚才新建的仓库地址 注:以上每一项：后都要空一格 部署到githubhexo d输入github账号密码，部署成功后就可以用github用户名.github.io来访问了。 hexo常用指令 hexo s 启动本地网站（修改网站或者写完一篇博客后可用此方法在本地看看效果） hexo g 生成静态文件 hexo d 部署网站","link":"/2020/05/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"图片转base64小工具","text":"最近需要学习python制作可视化程序的东西，看了一些教程选择了pysider2来学习。由于之前makedown文档总是上传不了图片，所以搜了搜发现可以用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置，于是想顺便练习一下做一个小工具。 UI设计我用的是Qt的界面生成器Qt Designer，拖拖拽拽就可以直观的创建出程序大体的界面 12345class Transfer: def __init__(self): self.ui = QUiLoader().load('base64_turn.ui') self.ui.btn_select.clicked.connect(self.open) self.ui.btn_start.clicked.connect(self.transfer) 通过上述代码实现ui文件的加载与方法的绑定 功能设计文件读取123456789101112131415def open(self): filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) if filePath == None: QMessageBox.information(self, '提示', '文件为空，请重新操作') else: self.pic_path = filePath pic=QtGui.QPixmap(self.pic_path) self.ui.qlb_pic.setPixmap(pic) #self.ui.qlb_pic.resize(pic.width(), pic.height()) self.ui.le_select.setText(self.pic_path) 通过 getExistingDirectory 静态方法 选择目录。该方法，第一个参数是父窗口对象，第二个参数是选择框显示的标题。 如果是选取单个文件，通过 getOpenFileName 静态方法 可以设置提示文本内容，比如 123456filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) 因为该方法返回的是一个元组，第一个元素是选择的文件路径，第二个元素是文件类型，如果你只想获取文件路径即可，可以采用上面的代码写法。 如果用户点击了 选择框的 取消选择按钮，返回 空字符串。 图像转换12345def transfer(self): f = open(self.pic_path, 'rb') # 二进制方式打开图文件 ls_f = base64.b64encode(f.read()) # 读取文件内容，转换为base64编码 f.close() self.ui.tb_base64.setText(str(ls_f)) 记得要import base64 文件已提交至github 第一次给github提交代码，每天进步一点点","link":"/2020/05/06/%E5%9B%BE%E7%89%87%E8%BD%ACbase64%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"title":"基于mobilenetv2的识别demo","text":"依旧是在练习pyside2的使用，这次做了一个图像识别的demo，用的mobilenet来做识别 UI设计UI设计还比较简陋，毕竟现在还只是个demo，而且下午组会就要展示 Qt designer的各种Layout布局还在摸索，这样松松垮垮的实在太丑了，而且我看别人做的程序运行时部分地方有个像C#各种布局的那种框框，哎日后慢慢完善吧 功能设计打开文件1234567891011121314151617181920def open(self): filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) if filePath is None: QMessageBox.information(self, '提示', '文件为空，请重新操作') else: self.pic_path = filePath pic = QtGui.QPixmap(self.pic_path) self.ui.lb_pic1.setPixmap(pic) self.ui.le_select.setText(self.pic_path) time1 = time.perf_counter() s = self.predict(self.pic_path) time2 = time.perf_counter() self.ui.lb_time.setText('识别时间：' + str(time2 - time1) + 's') self.ui.lb_recores.setText('识别结果：' + str(s)) # self.ui.qlb_pic.resize(pic.width(), pic.height()) 这次的open函数相较于上篇博客的稍微复杂一点点，逻辑大概是这样的：打开文件→将原图像显示到第一个label中→调用预测函数，将图片绝对路径传给预测函数→把识别所用时间和识别结果显示到窗口上。 预测123def predict(self, pic_path): str = predict_alter.predict(pic_path) return str 其实就是调用一下预测函数，这里多说几句。 我用的模型是B站UP主霹雳吧啦Wz的教学视频里的，这里是他的GitHub，他讲的深度学习图像分类真的非常详细。 这个predict_alter是我修改了一下原文件，用的是之前训练好的参数。 具体的预测函数我就不粘了。 数据我测试的数据是苹果品种标准叶片图像和光谱数据集，选取了五种苹果叶片的RGB图像 展示 这个里面的经度纬度啊拍摄时间啊，是因为我看到python的exifread库可以读取图像的一些信息（使用Python获取图像的信息)，想测试一下。 那个“选择识别的种类”的多选框是日后准备完善的内容，手里还有fruit、flower的两个数据集，质量都蛮好的 右侧其实放置了四块放图像的label，因为昨天还看到了opencv可以提取图像各通道信息，下午就要组会了，明天在完善吧。","link":"/2020/05/07/%E5%9F%BA%E4%BA%8EMobileNetv2%E7%9A%84%E8%AF%86%E5%88%ABdemo/"},{"title":"【pat】1001（Python format 格式化函数）","text":"艰难的刷题又开始了。 问题描述1001 A+B Format Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −106≤a,b≤106. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 解决方法之前开始过很多次刷题，但是算法和数据结构方面实在是太薄弱了，不管是LeetCode还是pat还是oj都坚持不下去，这次必拿下大概吧 做第一题就充分暴露对语言的不熟悉了，这道题我还跟大一一样试图用乘法和取余取到每三个数然后加”，“ 但其实做除法时例如999001%1000=1而不是001，实在是太笨了 1234567891011121314151617181920def cal_plus(): global rem,res line = input().split(\" \") a, b = int(line[0]), int(line[1]) sum = a + b if (0 &lt; sum &lt; 1000) or (-1000 &lt; sum &lt; 0): #print(sum) return str(sum) else: rem = sum % 1000 sum = int(sum / 1000) res = str(rem) while ((sum &gt; 0 and sum &lt; 1000) or (sum &lt; 0 and sum &lt; -1000)): rem = sum % 1000 sum = int(sum / 1000) res = str(rem) + ',' + res res =str(sum) + ',' + res return res #print(res) 但是我去搜了搜，发现了Python format 格式化函数，其实学python时啃从入门到实践看到过，现在全忘了。 1234def cal(): line = input().split(\" \") a, b = int(line[0]), int(line[1]) print(\"{:,}\".format(a + b)) 几行轻轻松松拿下。 笔记Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。 字符串格式化 format 函数可以接受不限个参数，位置可以不按顺序 12&quot;{} {}&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 不设置指定位置，按默认顺序'hello world' 12&quot;{0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置'hello world' 12&quot;{1} {0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置'world hello world' 也可以设置参数 123456789print(\"网站名：{name}, 地址 {url}\".format(name=\"菜鸟教程\", url=\"www.runoob.com\")) # 通过字典设置参数site = {\"name\": \"菜鸟教程\", \"url\": \"www.runoob.com\"}print(\"网站名：{name}, 地址 {url}\".format(**site)) # 通过列表索引设置参数my_list = ['菜鸟教程', 'www.runoob.com']print(\"网站名：{0[0]}, 地址 {0[1]}\".format(my_list)) # \"0\" 是必须的 输出结果为： 123网站名：菜鸟教程, 地址 www.runoob.com网站名：菜鸟教程, 地址 www.runoob.com网站名：菜鸟教程, 地址 www.runoob.com 也可以向 str.format() 传入对象 12345class AssignValue(object): def __init__(self, value): self.value = valuemy_value = AssignValue(6)print('value 为: {0.value}'.format(my_value)) # \"0\" 是可选的 输出结果为： 1value 为: 6 数字格式化^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。 + 表示在正数前显示 +，负数前显示 -； （空格）表示在正数前加空格 b、d、o、x 分别是二进制、十进制、八进制、十六进制。 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:&gt;10d} 13 右对齐 (默认, 宽度为10) 13 {:&lt;10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) 123456'{:b}'.format(11)'{:d}'.format(11)'{:o}'.format(11)'{:x}'.format(11)'{:#x}'.format(11)'{:#X}'.format(11) 12345610111113b0xb0XB 闲话 这次好好做一个题就总结一下，至少可以坚持下来多学点东西 其实还是蛮想在重新看一下java，这周快点把手里事情了了，尽量这周末看一下","link":"/2020/05/07/%E3%80%90pat%E3%80%911001/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"pyside2","slug":"pyside2","link":"/tags/pyside2/"},{"name":"pat","slug":"pat","link":"/tags/pat/"}],"categories":[]}